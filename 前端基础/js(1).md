<h2>●   get请求传参长度的误区 </h2><h3>参考回答：</h3> <div>  误区：我们经常说get请求参数的大小存在限制，而post请求的参数大小是无限制的。 </div> <p>  实际上HTTP 协议从未规定 GET/POST 的请求长度限制是多少。对get请求参数的限制是来源与浏览器或web服务器，浏览器或web服务器限制了url的长度。为了明确这个概念，我们必须再次强调下面几点: </p> <p>  HTTP 协议 未规定 GET 和POST的长度限制 </p> <p>  GET的最大长度显示是因为 浏览器和 web服务器限制了 URI的长度 </p> <p>  不同的浏览器和WEB服务器，限制的最大长度不一样 </p> <p>  要支持IE，则最大长度为2083byte，若只支持Chrome，则最大长度 8182byte </p><h2>●   补充get和post请求在缓存方面的区别 </h2><h3>参考回答：</h3> <div>  post/get的请求区别，具体不再赘述。 </div> <p>  补充补充一个get和post在缓存方面的区别： </p> <p>  get请求类似于查找的过程，用户获取数据，可以不用每次都与数据库连接，所以可以使用缓存。 </p> <p>  post不同，post做的一般是修改和删除的工作，所以必须与数据库交互，所以不能使用缓存。因此get请求适合于请求缓存。 </p><h2>●   说一下闭包 </h2><h3>参考回答：</h3> <div>  一句话可以概括：闭包就是能够读取其他函数内部变量的函数，或者子函数在外调用，子函数所在的父函数的作用域不会被释放。 </div><h2>●   说一下类的创建和继承 </h2><h3>参考回答：</h3> <div>  （1）类的创建（es5）：new一个function，在这个function的prototype里面增加属性和方法。 </div> <p>  下面来创建一个Animal类： </p> <p>  // 定义一个动物类 </p> <p>  function Animal (name) { </p> <p>  // 属性 </p> <p>  this.name = name || 'Animal'; </p> <p>  // 实例方法 </p> <p>  this.sleep = function(){ </p> <p>  console.log(this.name + '正在睡觉！'); </p> <p>  } </p> <p>  } </p> <p>  // 原型方法 </p> <p>  Animal.prototype.eat = function(food) { </p> <p>  console.log(this.name + '正在吃：' + food); </p> <p>  }; </p> <p>  这样就生成了一个Animal类，实力化生成对象后，有方法和属性。 </p> <p>  （2）类的继承——原型链继承 </p> <p>  --原型链继承 </p> <pre>function Cat(){ }↵Cat.prototype = new Animal();↵Cat.prototype.name = 'cat';↵//　Test Code↵var cat = new Cat();↵console.log(cat.name);↵console.log(cat.eat('fish'));↵console.log(cat.sleep());↵console.log(cat instanceof Animal); //true↵console.log(cat instanceof Cat); //true</pre> <p>  介绍：在这里我们可以看到new了一个空对象,这个空对象指向Animal并且Cat.prototype指向了这个空对象，这种就是基于原型链的继承。 </p> <p>  特点：基于原型链，既是父类的实例，也是子类的实例 </p> <p>  缺点：无法实现多继承 </p> <p>  （3）构造继承：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型） </p> <pre>function Cat(name){↵Animal.call(this);↵this.name = name || 'Tom';↵}↵// Test Code↵var cat = new Cat();↵console.log(cat.name);↵console.log(cat.sleep());↵console.log(cat instanceof Animal); // false↵console.log(cat instanceof Cat); // true</pre> <p>  特点：可以实现多继承 </p> <p>  缺点：只能继承父类实例的属性和方法，不能继承原型上的属性和方法。 </p> <p>  （4）实例继承和拷贝继承 </p> <p>  实例继承：为父类实例添加新特性，作为子类实例返回 </p> <p>  拷贝继承：拷贝父类元素上的属性和方法 </p> <p>  上述两个实用性不强，不一一举例。 </p> <p>  （5）组合继承：相当于构造继承和原型链继承的组合体。通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用 </p> <pre>function Cat(name){↵Animal.call(this);↵this.name = name || 'Tom';↵}↵Cat.prototype = new Animal();↵Cat.prototype.constructor = Cat;↵// Test Code↵var cat = new Cat();↵console.log(cat.name);↵console.log(cat.sleep());↵console.log(cat instanceof Animal); // true↵console.log(cat instanceof Cat); // true</pre> <p>  特点：可以继承实例属性/方法，也可以继承原型属性/方法 </p> <p>  缺点：调用了两次父类构造函数，生成了两份实例 </p> <p>  （6）寄生组合继承：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性 </p> <pre>function Cat(name){↵Animal.call(this);↵this.name = name || 'Tom';↵}↵(function(){</pre> <p>  // 创建一个没有实例方法的类 </p> <pre class="prettyprint lang-css">var Super = function(){};↵Super.prototype = Animal.prototype;</pre> <p>  //将实例作为子类的原型 </p> <pre class="prettyprint lang-css">Cat.prototype = new Super();↵})();↵// Test Code↵var cat = new Cat();↵console.log(cat.name);↵console.log(cat.sleep());↵console.log(cat instanceof Animal); // true↵console.log(cat instanceof Cat); //true</pre> <p>  较为推荐 </p><h2>●   如何解决异步回调地狱 </h2><h3>参考回答：</h3> <pre class="prettyprint lang-css">promise、generator、async/await</pre> <br /><h2>●   说说前端中的事件流 </h2><h3>参考回答：</h3> <div>  HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件onclick、页面的滚动事件onscroll等等，可以向文档或者文档中的元素添加事件侦听器来预订事件。想要知道这些事件是在什么时候进行调用的，就需要了解一下“事件流”的概念。 </div> <p>  什么是事件流：事件流描述的是从页面中接收事件的顺序,DOM2级事件流包括下面几个阶段。 </p> <p>  事件捕获阶段 </p> <p>  处于目标阶段 </p> <p>  事件冒泡阶段 </p> <p>  addEventListener：addEventListener 是DOM2 级事件新增的指定事件处理程序的操作，这个方法接收3个参数：要处理的事件名、作为事件处理程序的函数和一个布尔值。最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。 </p> <p>  IE只支持事件冒泡。 </p><h2>●   如何让事件先冒泡后捕获 </h2><h3>参考回答：</h3> <div>  在DOM标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果，对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获之间。 </div><h2>●   说一下事件委托 </h2><h3>参考回答：</h3> <div>  简介：事件委托指的是，不在事件的发生地（直接dom）上设置监听函数，而是在其父元素上设置监听函数，通过事件冒泡，父元素可以监听到子元素上事件的触发，通过判断事件发生元素DOM的类型，来做出不同的响应。 </div> <p>  举例：最经典的就是ul和li标签的事件监听，比如我们在添加事件时候，采用事件委托机制，不会在li标签上直接添加，而是在ul父元素上添加。 </p> <p>  好处：比较合适动态元素的绑定，新添加的子元素也会有监听函数，也可以有事件触发机制。 </p><h2>●   说一下图片的懒加载和预加载 </h2><h3>参考回答：</h3> <div>  预加载：提前加载图片，当用户需要查看时可直接从本地缓存中渲染。<br /> </div> <p>  懒加载：懒加载的主要目的是作为服务器前端的优化，减少请求数或延迟请求数。 </p> <p>  <br /> </p> <p>  两种技术的本质：两者的行为是相反的，一个是提前加载，一个是迟缓甚至不加载。<br /> 懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。 </p><h2>●   mouseover和mouseenter的区别 </h2><h3>参考回答：</h3> <div>  mouseover：当鼠标移入元素或其子元素都会触发事件，所以有一个重复触发，冒泡的过程。对应的移除事件是mouseout </div> <p>  mouseenter：当鼠标移除元素本身（不包含元素的子元素）会触发事件，也就是不会冒泡，对应的移除事件是mouseleave </p><h2>●   js的new操作符做了哪些事情 </h2><h3>参考回答：</h3> <div>  new 操作符新建了一个空对象，这个对象原型指向构造函数的prototype，执行构造函数后返回这个对象。 </div><h2>●   改变函数内部this指针的指向函数（bind，apply，call的区别） </h2><h3>参考回答：</h3> <div>  通过apply和call改变函数的this指向，他们两个函数的第一个参数都是一样的表示要改变指向的那个对象，第二个参数，apply是数组，而call则是arg1,arg2...这种形式。<span>通过bind改变this作用域会返回一个新的函数，这个函数不会马上执行。</span>  </div><h2>●   js的各种位置，比如clientHeight,scrollHeight,offsetHeight ,以及scrollTop, offsetTop,clientTop的区别？ </h2><h3>参考回答：</h3> <div>  clientHeight：表示的是可视区域的高度，不包含border和滚动条<br /> </div> <p>  offsetHeight：表示可视区域的高度，包含了border和滚动条 </p> <p>  scrollHeight：表示了所有区域的高度，包含了因为滚动被隐藏的部分。 </p> <p>  clientTop：表示边框border的厚度，在未指定的情况下一般为0 </p> <p>  scrollTop：滚动后被隐藏的高度，获取对象相对于由offsetParent属性指定的父坐标(css定位的元素或body元素)距离顶端的高度。 </p><h2>●   js拖拽功能的实现 </h2><h3>参考回答：</h3> <div>  首先是三个事件，分别是mousedown，mousemove，mouseup </div> 当鼠标点击按下的时候，需要一个tag标识此时已经按下，可以执行mousemove里面的具体方法。 <p>  <br /> </p> <p>  <br /> </p> <p>  clientX，clientY标识的是鼠标的坐标，分别标识横坐标和纵坐标，并且我们用offsetX和offsetY来表示元素的元素的初始坐标，移动的举例应该是： </p> <p>  <br /> </p> <p>  鼠标移动时候的坐标-鼠标按下去时候的坐标。 </p> <p>  <br /> </p> <p>  也就是说定位信息为： </p> <p>  <br /> </p> <p>  鼠标移动时候的坐标-鼠标按下去时候的坐标+元素初始情况下的offetLeft. </p> <p>  <br /> </p> <p>  <br /> </p> <p>  还有一点也是原理性的东西，也就是拖拽的同时是绝对定位，我们改变的是绝对定位条件下的left<br /> 以及top等等值。 </p> <p>  <br /> </p> <p>  补充：也可以通过html5的拖放（Drag 和 drop）来实现 </p><h2>●   异步加载js的方法 </h2><h3>参考回答：</h3> <div>  defer：只支持IE如果您的脚本不会改变文档的内容，可将 defer 属性加入到&lt;script&gt;标签中，以便加快处理文档的速度。因为浏览器知道它将能够安全地读取文档的剩余部分而不用执行脚本，它将推迟对脚本的解释，直到文档已经显示给用户为止。 </div> <div>  <span>async，HTML5属性仅适用于外部脚本，并且如果在IE中，同时存在defer和async，那么defer的优先级比较高，脚本将在页面完成时执行。</span>  </div> <p>  <span>创建script标签，插入到DOM中</span>  </p><h2>●   Ajax解决浏览器缓存问题 </h2><h3>参考回答：</h3> <div>  在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。 </div> <p>  <br /> </p> <p>  <br /> </p> <p>  在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)。 </p> <p>  <br /> </p> <p>  <br /> </p> <p>  在URL后面加上一个随机数： &quot;fresh=&quot; + Math.random()。 </p> <p>  <br /> </p> <p>  <br /> </p> <p>  在URL后面加上时间搓：&quot;nowtime=&quot; + new Date().getTime()。 </p> <p>  <br /> </p> <p>  <br /> </p> <p>  如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。 </p><h2>●   js的节流和防抖 </h2><h3>参考回答：</h3>  <a href="http://www.cnblogs.com/coco1s/p/5499469.html" target="_blank">http://www.cnblogs.com/coco1s/p/5499469.html</a>  <h2>●   JS中的垃圾回收机制 </h2><h3>参考回答：</h3> <div>  必要性：由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用，否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。 </div> <p>  这段话解释了为什么需要系统需要垃圾回收，JS不像C/C++，他有自己的一套垃圾回收机制（Garbage Collection）。JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。例如： </p> <pre>var a=&quot;hello world&quot;;↵var b=&quot;world&quot;;↵var a=b;</pre> <p>  //这时，会释放掉&quot;hello world&quot;，释放内存以便再引用 </p> <p>  垃圾回收的方法：标记清除、计数引用。 </p> <p>  标记清除 </p> <p>  这是最常见的垃圾回收方式，当变量进入环境时，就标记这个变量为”进入环境“,从逻辑上讲，永远不能释放进入环境的变量所占的内存，永远不能释放进入环境变量所占用的内存，只要执行流程进入相应的环境，就可能用到他们。当离开环境时，就标记为离开环境。 </p> <p>  垃圾回收器在运行的时候会给存储在内存中的变量都加上标记（所有都加），然后去掉环境变量中的变量，以及被环境变量中的变量所引用的变量（条件性去除标记），删除所有被标记的变量，删除的变量无法在环境变量中被访问所以会被删除，最后垃圾回收器，完成了内存的清除工作，并回收他们所占用的内存。 </p> <p>  引用计数法 </p> <p>  另一种不太常见的方法就是引用计数法，引用计数法的意思就是每个值没引用的次数，当声明了一个变量，并用一个引用类型的值赋值给改变量，则这个值的引用次数为1,；相反的，如果包含了对这个值引用的变量又取得了另外一个值，则原先的引用值引用次数就减1，当这个值的引用次数为0的时候，说明没有办法再访问这个值了，因此就把所占的内存给回收进来，这样垃圾收集器再次运行的时候，就会释放引用次数为0的这些值。 </p> <p>  用引用计数法会存在内存泄露，下面来看原因： </p> <pre>function problem() {↵var objA = new Object();↵var objB = new Object();↵objA.someOtherObject = objB;↵objB.anotherObject = objA;↵}</pre> <p>  在这个例子里面，objA和objB通过各自的属性相互引用，这样的话，两个对象的引用次数都为2，在采用引用计数的策略中，由于函数执行之后，这两个对象都离开了作用域，函数执行完成之后，因为计数不为0，这样的相互引用如果大量存在就会导致内存泄露。 </p> <p>  特别是在DOM对象中，也容易存在这种问题： </p> <pre>var element=document.getElementById（’‘）；↵var myObj=new Object();↵myObj.element=element;↵element.someObject=myObj;</pre> <p>  这样就不会有垃圾回收的过程。 </p><h2>●   eval是做什么的 </h2><h3>参考回答：</h3> <div>  它的功能是将对应的字符串解析成js并执行，应该避免使用js，因为非常消耗性能（2次，一次解析成js，一次执行） </div><h2>●   如何理解前端模块化 </h2><h3>参考回答：</h3> <div>  前端模块化就是复杂的文件编程一个一个独立的模块，比如js文件等等，分成独立的模块有利于重用（复用性）和维护（版本迭代），这样会引来模块之间相互依赖的问题，所以有了commonJS规范，AMD，CMD规范等等，以及用于js打包（编译等处理）的工具webpack </div><h2>●   说一下Commonjs、AMD和CMD </h2><h3>参考回答：</h3> <div>  一个模块是能实现特定功能的文件，有了模块就可以方便的使用别人的代码，想要什么功能就能加载什么模块。 </div> <p>  Commonjs：开始于服务器端的模块化，同步定义的模块化，每个模块都是一个单独的作用域，模块输出，modules.exports，模块加载require()引入模块。 </p> <p>  AMD：中文名异步模块定义的意思。 </p> <p>  requireJS实现了AMD规范，主要用于解决下述两个问题。 </p> <p>  1.多个文件有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器 </p> <p>  <br /> </p> <p>  2.加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应的时间越长。 </p> <p>  语法：requireJS定义了一个函数define，它是全局变量，用来定义模块。 </p> <p>  requireJS的例子： </p> <p>  //定义模块 </p> <pre>define(['dependency'], function(){↵var name = 'Byron';↵function printName(){↵console.log(name);↵}↵return {↵printName: printName↵};↵});</pre> <p>  //加载模块 </p> <pre>require(['myModule'], function (my){↵my.printName();↵}</pre> <p>  requirejs定义了一个函数define,它是全局变量，用来定义模块： </p> <p>  define(id?dependencies?,factory) </p> <p>  在页面上使用模块加载函数： </p> <p>  require([dependencies],factory)； </p> <p>  总结AMD规范：require（）函数在加载依赖函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块加载成功，才会去执行。<br /> 因为网页在加载js的时候会停止渲染，因此我们可以通过异步的方式去加载js,而如果需要依赖某些，也是异步去依赖，依赖后再执行某些方法。 </p><h2>●   对象深度克隆的简单实现 </h2><h3>参考回答：</h3> <pre>function deepClone(obj){↵var newObj= obj instanceof Array ? []:{};↵for(var item in obj){↵var temple= typeof obj[item] == 'object' ? deepClone(obj[item]):obj[item];↵newObj[item] = temple;↵}↵return newObj;↵}</pre> <p>  ES5的常用的对象克隆的一种方式。注意数组是对象，但是跟对象又有一定区别，所以我们一开始判断了一些类型，决定newObj是对象还是数组~ </p><h2>●   实现一个once函数，传入函数参数只执行一次 </h2><h3>参考回答：</h3> <pre class="prettyprint lang-css">function ones(func){↵var tag=true;↵return function(){↵if(tag==true){↵func.apply(null,arguments);↵tag=false;↵}↵return undefined↵}↵}</pre> <br /><h2>●   将原生的ajax封装成promise </h2><h3>参考回答：</h3> <pre class="prettyprint lang-css">var  myNewAjax=function(url){↵return new Promise(function(resolve,reject){↵var xhr = new XMLHttpRequest();↵xhr.open('get',url);↵xhr.send(data);↵xhr.onreadystatechange=function(){↵if(xhr.status==200&amp;&amp;readyState==4){↵var json=JSON.parse(xhr.responseText);↵resolve(json)↵}else if(xhr.readyState==4&amp;&amp;xhr.status!=200){↵reject('error');↵}↵}↵})↵}</pre> <br /><h2>●   js监听对象属性的改变 </h2><h3>参考回答：</h3> <div>  我们假设这里有一个user对象, </div> <p>  (1)在ES5中可以通过Object.defineProperty来实现已有属性的监听 </p> <pre>Object.defineProperty(user,'name',{↵set：function(key,value){↵}↵})</pre> <p>  缺点：如果id不在user对象中，则不能监听id的变化 </p> <p>  (2)在ES6中可以通过Proxy来实现 </p> <pre>var  user = new Proxy({}，{↵set：function(target,key,value,receiver){↵}↵})</pre> <p>  这样即使有属性在user中不存在，通过user.id来定义也同样可以这样监听这个属性的变化哦~ </p><h2>●   如何实现一个私有变量，用getName方法可以访问，不能直接访问 </h2><h3>参考回答：</h3> <div>  (1)通过defineProperty来实现 </div> <pre>obj={↵name:yuxiaoliang,↵getName:function(){↵return this.name↵}↵}↵object.defineProperty(obj,&quot;name&quot;,{</pre> <p>  //不可枚举不可配置 </p> <p>  }); </p> <p>  (2)通过函数的创建形式 </p> <pre class="prettyprint lang-css">function product(){↵var name='yuxiaoliang';↵this.getName=function(){↵return name;↵}↵}↵var obj=new product();</pre> <br /><h2>●   ==和===、以及Object.is的区别 </h2><h3>参考回答：</h3> <div>  (1) == </div> <p>  主要存在：强制转换成number,null==undefined </p> <p>  &quot; &quot;==0  //true </p> <p>  &quot;0&quot;==0  //true </p> <p>  &quot; &quot; !=&quot;0&quot; //true </p> <p>  123==&quot;123&quot; //true </p> <p>  null==undefined //true </p> <p>  (2)Object.js </p> <p>  主要的区别就是+0！=-0 而NaN==NaN<br /> (相对比===和==的改进) </p><h2>●   setTimeout、setInterval和requestAnimationFrame之间的区别 </h2><h3>参考回答：</h3> <div>  这里有一篇文章讲的是requestAnimationFrame：<a href="http://www.cnblogs.com/xiaohuochai/p/5777186.html" target="_blank">http://www.cnblogs.com/xiaohuochai/p/5777186.html</a>  </div> 与setTimeout和setInterval不同，requestAnimationFrame不需要设置时间间隔，<br /> 大多数电脑显示器的刷新频率是60Hz，大概相当于每秒钟重绘60次。大多数浏览器都会对重绘操作加以限制，不超过显示器的重绘频率，因为即使超过那个频率用户体验也不会有提升。因此，最平滑动画的最佳循环间隔是1000ms/60，约等于16.6ms。 <p>  RAF采用的是系统时间间隔，不会因为前面的任务，不会影响RAF，但是如果前面的任务多的话，<br /> 会响应setTimeout和setInterval真正运行时的时间间隔。 </p> <p>  特点：<br /> （1）requestAnimationFrame会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率。 </p> <p>  （2）在隐藏或不可见的元素中，requestAnimationFrame将不会进行重绘或回流，这当然就意味着更少的CPU、GPU和内存使用量 </p> <p>  （3）requestAnimationFrame是由浏览器专门为动画提供的API，在运行时浏览器会自动优化方法的调用，并且如果页面不是激活状态下的话，动画会自动暂停，有效节省了CPU开销。 </p><h2>●   实现一个两列等高布局，讲讲思路 </h2><h3>参考回答：</h3> <div>  为了实现两列等高，可以给每列加上 padding-bottom:9999px; </div> <p>  margin-bottom:-9999px;同时父元素设置overflow:hidden; </p><h2>●   自己实现一个bind函数 </h2><h3>参考回答：</h3> <p>  原理：通过apply或者call方法来实现。 </p> <p>  (1)初始版本 </p> <pre>Function.prototype.bind=function(obj,arg){↵var arg=Array.prototype.slice.call(arguments,1);↵var context=this;↵return function(newArg){↵arg=arg.concat(Array.prototype.slice.call(newArg));↵return context.apply(obj,arg);↵}↵}</pre> <p>  (2) 考虑到原型链 </p> <p>  为什么要考虑？因为在new 一个bind过生成的新函数的时候，必须的条件是要继承原函数的原型 </p> <pre>Function.prototype.bind=function(obj,arg){↵var arg=Array.prototype.slice.call(arguments,1);↵var context=this;↵var bound=function(newArg){↵arg=arg.concat(Array.prototype.slice.call(newArg));↵return context.apply(obj,arg);↵}↵var F=function(){}</pre> <p>  //这里需要一个寄生组合继承 </p> <pre class="prettyprint lang-cpp">F.prototype=context.prototype;↵bound.prototype=new F();↵return bound;↵}</pre> <br /><h2>●   用setTimeout来实现setInterval </h2><h3>参考回答：</h3> <div>  (1)用setTimeout()方法来模拟setInterval()与setInterval()之间的什么区别？ </div> <p>  首先来看setInterval的缺陷，使用setInterval()创建的定时器确保了定时器代码规则地插入队列中。这个问题在于：如果定时器代码在代码再次添加到队列之前还没完成执行，结果就会导致定时器代码连续运行好几次。而之间没有间隔。不过幸运的是：javascript引擎足够聪明，能够避免这个问题。当且仅当没有该定时器的如何代码实例时，才会将定时器代码添加到队列中。这确保了定时器代码加入队列中最小的时间间隔为指定时间。 </p> <p>  这种重复定时器的规则有两个问题：1.某些间隔会被跳过 2.多个定时器的代码执行时间可能会比预期小。 </p> <p>  下面举例子说明： </p> <p>  假设，某个onclick事件处理程序使用啦setInterval()来设置了一个200ms的重复定时器。如果事件处理程序花了300ms多一点的时间完成。 </p> <p>  &lt;img width=&quot;626&quot; alt=&quot;2018-07-10 11 36 43&quot; src=&quot;<a href="https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png" target="_blank">https://user-images.githubusercontent.com/17233651/42487876-92656f2c-8435-11e8-8a5f-0a97918039da.png</a>&quot;&gt; </p> <p>  这个例子中的第一个定时器是在205ms处添加到队列中，但是要过300ms才能执行。在405ms又添加了一个副本。在一个间隔，605ms处，第一个定时器代码还在执行中，而且队列中已经有了一个定时器实例，结果是605ms的定时器代码不会添加到队列中。结果是在5ms处添加的定时器代码执行结束后，405处的代码立即执行。 </p> <pre>function say(){↵//something↵setTimeout(say,200);↵}↵setTimeout(say,200)</pre> <p>  或者 </p> <pre class="prettyprint lang-css">setTimeout(function(){↵//do something↵setTimeout(arguments.callee,200);↵},200);</pre> <br /><h2>●   js怎么控制一次加载一张图片，加载完后再加载下一张 </h2><h3>参考回答：</h3> <div>  (1)方法1 </div> <pre>&lt;script type=&quot;text/javascript&quot;&gt;↵var obj=new Image();↵obj.src=&quot;<a href="http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg" target="_blank">http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg</a>&quot;;↵obj.onload=function(){</pre> <p>  alert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height); </p> <pre>document.getElementById(&quot;mypic&quot;).innnerHTML=&quot;&lt;img src='&quot;+this.src+&quot;' /&gt;&quot;;↵}↵&lt;/script&gt;↵&lt;div id=&quot;mypic&quot;&gt;onloading……&lt;/div&gt;</pre> <p>  (2)方法2 </p> <pre>&lt;script type=&quot;text/javascript&quot;&gt;↵var obj=new Image();↵obj.src=&quot;<a href="http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg" target="_blank">http://www.phpernote.com/uploadfiles/editor/201107240502201179.jpg</a>&quot;;↵obj.onreadystatechange=function(){↵if(this.readyState==&quot;complete&quot;){</pre> <p>  alert('图片的宽度为：'+obj.width+'；图片的高度为：'+obj.height); </p> <pre class="prettyprint lang-css">document.getElementById(&quot;mypic&quot;).innnerHTML=&quot;&lt;img src='&quot;+this.src+&quot;' /&gt;&quot;;↵}↵}↵&lt;/script&gt;↵&lt;div id=&quot;mypic&quot;&gt;onloading……&lt;/div&gt;</pre> <br /><h2>●   代码的执行顺序 </h2><h3>参考回答：</h3> <pre>setTimeout(function(){console.log(1)},0);↵new Promise(function(resolve,reject){↵console.log(2);↵resolve();↵}).then(function(){console.log(3)↵}).then(function(){console.log(4)});↵process.nextTick(function(){console.log(5)});↵console.log(6);</pre> <p>  //输出2,6,5,3,4,1 </p> <p>  为什么呢？具体请参考我的文章：<a href="https://github.com/forthealllight/blog/issues/5" target="_blank"><br /> 从promise、process.nextTick、setTimeout出发，谈谈Event Loop中的Job queue</a>  </p><h2>●   如何实现sleep的效果（es5或者es6） </h2><h3>参考回答：</h3> <div>  (1)while循环的方式 </div> <pre>function sleep(ms){↵var start=Date.now(),expire=start+ms;↵while(Date.now()&lt;expire);↵console.log('1111');↵return;↵}</pre> <p>  执行sleep(1000)之后，休眠了1000ms之后输出了1111。上述循环的方式缺点很明显，容易造成死循环。 </p> <p>  (2)通过promise来实现 </p> <pre>function sleep(ms){↵var temple=new Promise(↵(resolve)=&gt;{↵console.log(111);setTimeout(resolve,ms)↵});↵return temple↵}↵sleep(500).then(function(){↵//console.log(222)↵})</pre> <p>  //先输出了111，延迟500ms后输出222 </p> <p>  (3)通过async封装 </p> <pre>function sleep(ms){↵return new Promise((resolve)=&gt;setTimeout(resolve,ms));↵}↵async function test(){↵var temple=await sleep(1000);↵console.log(1111)↵return temple↵}↵test();</pre> <p>  //延迟1000ms输出了1111 </p> <p>  (4).通过generate来实现 </p> <pre class="prettyprint lang-css">function* sleep(ms){↵yield new Promise(function(resolve,reject){↵console.log(111);↵setTimeout(resolve,ms);↵})↵}↵sleep(500).next().value.then(function(){console.log(2222)})</pre> <br /><h2>●   简单的实现一个promise </h2><h3>参考回答：</h3> <div>  <a href="https://promisesaplus.com/" target="_blank">首先明</a><a href="https://promisesaplus.com/" target="_blank">确什么是promiseA+规范，参考规范的地址：primise</a>  </div> <p>  A+规范 </p> <p>  如何实现一个promise，参考我的文章： </p> <p>  <a href="https://github.com/forthealllight/blog/issues/4" target="_blank">实现一个完美符合Promise/A+规范的Promise</a>  </p> <p>  一般不会问的很详细，只要能写出上述文章中的v1.0版本的简单promise即可。 </p><h2>●   Function._proto_(getPrototypeOf)是什么？ </h2><h3>参考回答：</h3> <div>  获取一个对象的原型，在chrome中可以通过_proto_的形式，或者在ES6中可以通过Object.getPrototypeOf的形式。 </div> <p>  那么Function.proto是什么么？也就是说Function由什么对象继承而来，我们来做如下判别。 </p> <p>  Function.__proto__==Object.prototype //false </p> <p>  Function.__proto__==Function.prototype//true </p> <p>  我们发现Function的原型也是Function。 </p> <p>  我们用图可以来明确这个关系： </p> <p>  &lt;img width=&quot;646&quot; alt=&quot;2018-07-10 2 38 27&quot; src=&quot;<a href="https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png" target="_blank">https://user-images.githubusercontent.com/17233651/42493275-f55d0860-844e-11e8-983f-e04189a4f3d8.png</a>&quot;&gt; </p><h2>●   实现js中所有对象的深度克隆（包装对象，Date对象，正则对象） </h2><h3>参考回答：</h3> <div>  通过递归可以简单实现对象的深度克隆，但是这种方法不管是ES6还是ES5实现，都有同样的缺陷，就是只能实现特定的object的深度复制（比如数组和函数），不能实现包装对象Number，String ， Boolean，以及Date对象，RegExp对象的复制。 </div> <p>  (1)前文的方法 </p> <pre>function deepClone(obj){↵var newObj= obj instanceof Array?[]:{};↵for(var i in obj){↵newObj[i]=typeof obj[i]=='object'?↵deepClone(obj[i]):obj[i];↵}↵return newObj;↵}</pre> <p>  这种方法可以实现一般对象和数组对象的克隆，比如： </p> <pre>var arr=[1,2,3];↵var newArr=deepClone(arr);↵// newArr-&gt;[1,2,3]↵var obj={↵x:1,↵y:2↵}↵var newObj=deepClone(obj);↵// newObj={x:1,y:2}</pre> <p>  但是不能实现例如包装对象Number,String,Boolean,以及正则对象RegExp和Date对象的克隆，比如： </p> <p>  //Number包装对象 </p> <pre>var num=new Number(1);↵typeof num // &quot;object&quot;↵var newNum=deepClone(num);</pre> <p>  //newNum -&gt;  {} 空对象 </p> <p>  <br /> </p> <p>  //String包装对象 </p> <pre>var str=new String(&quot;hello&quot;);↵typeof str //&quot;object&quot;↵var newStr=deepClone(str);↵//newStr-&gt;  {0:'h',1:'e',2:'l',3:'l',4:'o'};</pre> <p>  <br /> </p> <p>  //Boolean包装对象 </p> <pre>var bol=new Boolean(true);↵typeof bol //&quot;object&quot;↵var newBol=deepClone(bol);</pre> <p>  // newBol -&gt;{} 空对象 </p> <p>  <br /> </p> <p>  .... </p> <p>  (2)valueof()函数 </p> <p>  所有对象都有valueOf方法，valueOf方法对于：如果存在任意原始值，它就默认将对象转换为表示它的原始值。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此默认的valueOf()方法简单地返回对象本身，而不是返回一个原始值。数组、函数和正则表达式简单地继承了这个默认方法，调用这些类型的实例的valueOf()方法只是简单返回这个对象本身。 </p> <p>  对于原始值或者包装类： </p> <pre>function baseClone(base){↵return base.valueOf();↵}↵//Number↵var num=new Number(1);↵var newNum=baseClone(num);↵//newNum-&gt;1↵//String↵var str=new String('hello');↵var newStr=baseClone(str);↵// newStr-&gt;&quot;hello&quot;↵//Boolean↵var bol=new Boolean(true);↵var newBol=baseClone(bol);↵//newBol-&gt; true</pre> <p>  其实对于包装类，完全可以用=号来进行克隆，其实没有深度克隆一说， </p> <p>  这里用valueOf实现，语法上比较符合规范。 </p> <p>  对于Date类型： </p> <p>  因为valueOf方法，日期类定义的valueOf()方法会返回它的一个内部表示：1970年1月1日以来的毫秒数.因此我们可以在Date的原型上定义克隆的方法： </p> <pre>Date.prototype.clone=function(){↵return new Date(this.valueOf());↵}↵var date=new Date('2010');↵var newDate=date.clone();↵// newDate-&gt;  Fri Jan 01 2010 08:00:00 GMT+0800</pre> <p>  对于正则对象RegExp： </p> <pre class="prettyprint lang-css">RegExp.prototype.clone = function() {↵var pattern = this.valueOf();↵var flags = '';↵flags += pattern.global ? 'g' : '';↵flags += pattern.ignoreCase ? 'i' : '';↵flags += pattern.multiline ? 'm' : '';↵return new RegExp(pattern.source, flags);↵};↵var reg=new RegExp('/111/');↵var newReg=reg.clone();↵//newReg-&gt;  /\/111\//</pre> <br /><h2>●   简单实现Node的Events模块 </h2><h3>参考回答：</h3> <div>  简介：观察者模式或者说订阅模式，它定义了对象间的一种一对多的关系，让多个观察者对象同时监听某一个主题对象，当一个对象发生改变时，所有依赖于它的对象都将得到通知。 </div> <p>  node中的Events模块就是通过观察者模式来实现的： </p> <pre>var events=require('events');↵var eventEmitter=new events.EventEmitter();↵eventEmitter.on('say',function(name){↵console.log('Hello',name);↵})↵eventEmitter.emit('say','Jony yu');</pre> <p>  这样，eventEmitter发出say事件，通过On接收，并且输出结果，这就是一个订阅模式的实现，下面我们来简单的实现一个Events模块的EventEmitter。 </p> <p>  (1)实现简单的Event模块的emit和on方法 </p> <pre>function Events(){↵this.on=function(eventName,callBack){↵if(!this.handles){↵this.handles={};↵}↵if(!this.handles[eventName]){↵this.handles[eventName]=[];↵}↵this.handles[eventName].push(callBack);↵}↵this.emit=function(eventName,obj){↵if(this.handles[eventName]){↵for(var i=0;o&lt;this.handles[eventName].length;i++){↵this.handles[eventName][i](obj);↵}↵}↵}↵return this;↵}</pre> <p>  这样我们就定义了Events，现在我们可以开始来调用： </p> <pre>var events=new Events();↵events.on('say',function(name){↵console.log('Hello',nama)↵});↵events.emit('say','Jony yu');</pre> <p>  //结果就是通过emit调用之后，输出了Jony yu </p> <p>  (2)每个对象是独立的 </p> <p>  因为是通过new的方式，每次生成的对象都是不相同的，因此： </p> <pre>var event1=new Events();↵var event2=new Events();↵event1.on('say',function(){↵console.log('Jony event1');↵});↵event2.on('say',function(){↵console.log('Jony event2');↵})↵event1.emit('say');↵event2.emit('say');</pre> <p>  //event1、event2之间的事件监听互相不影响 </p> <p>  //输出结果为'Jony event1' 'Jony event2' </p><h2>●   箭头函数中this指向举例 </h2><h3>参考回答：</h3> <pre>var a=11;↵function test2(){↵this.a=22;↵let b=()=&gt;{console.log(this.a)}↵b();↵}↵var x=new test2();</pre> <p>  //输出22 </p> <p>  定义时绑定。 </p>